"Pathogen needs to loaded before any other plugins and settings
call pathogen#runtime_append_all_bundles()

"===GENERAL SETTINGS===
set t_Co=256
set fileencodings=ucs-bom,utf-8,gbk,gb18030,gb2312,default,latin1
if v:version < 703
	set number
else 
	set relativenumber
endif
set shiftwidth=4
set tabstop=4
set softtabstop=4
set backspace=2
set statusline=\ %F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l/%L:%c
set laststatus=2
set ruler
set autoread
set incsearch
set ignorecase smartcase
set autoindent
set smartindent
set cinkeys=0{,0},!^F,o,O,e " default is: 0{,0},0),:,0#,!^F,o,O,e
set iskeyword=a-z,A-Z,48-57,_
set history=1000
"buffer setting
set switchbuf=useopen,usetab
"leave a buffer without saving
set hidden 
set wildchar=<Tab> wildmenu wildmode=full
:filetype plugin on 
:filetype indent on
:syntax on
"cscope
set cscopequickfix=s-,c-,d-,i-,t-,e-
if filereadable("cscope.out")
    cs add cscope.out
endif

"====COLOR SCHEME====
let g:CSApprox_loaded = 1
let g:CSApprox_verbose_level = 0
if has("gui_running")
    colorscheme desert
else
	colorscheme desert256
endif

"====FILETYPE SETTING===
autocmd BufReadPost *
\ if line("'\"") > 0 && line ("'\"") <= line("$") |
\   exe "normal g'\"" |
\ endif

autocmd BufRead *.cu setf cpp 
autocmd BufRead *.cuh setf cpp 
autocmd BufRead *.m setf objc
autocmd BufRead *.doctest setf python
autocmd BufNewFile,BufRead *.as setf actionscript


autocmd BufWritePost *.sh silent !chmod +x %
autocmd BufWritePost *.pl silent !chmod +x %

if &term=="xterm"
     set t_Co=8
     set t_Sb=[4%dm
     set t_Sf=[3%dm
endif

if v:lang =~ "utf8$" || v:lang =~ "UTF-8$"
   set fileencodings=utf-8,latin1
endif

"=====KEY MAPPING===
let mapleader = ","
nnoremap s ;
nnoremap S ,
imap <C-V> <C-R>"
imap <S-CR> <ESC>
vmap <S-CR> <ESC>
imap <C-B> <C-O>b
imap <C-F> <C-O>w
imap <C-H> <C-O>h
imap <C-J> <C-O>j
imap <C-K> <C-O>k
imap <C-L> <C-O>l
imap <C-A> <C-O>^
imap <C-E> <C-O>$
imap <C-S> <C-O>dw
imap <C-D> <C-O>x
inoremap # X<BS>#
nmap <leader>nu :set number<CR>
nmap <leader>rn :set rnu<CR>
nmap <leader>xx :qa!<CR>
nmap j gj
nmap k gk
nmap <leader>te :tabnew<cr>
nmap <leader>tc :tabclose<cr>
nmap <leader>tn :tabn<cr>
nmap <leader>tp :tabp<cr>
nmap <leader>bn :bnext<cr>
nmap <leader>bp :bprev<cr>
nmap <leader>en :enew<cr>
nmap <leader>, :b#<cr>
nmap <leader>sb :sb#<cr>
nmap <leader>vs :vertical sb#<cr>
nmap <leader>wj <C-W>j
nmap <leader>wk <C-W>k
nmap <leader>wh <C-W>h
nmap <leader>wl <C-W>l
nmap <leader>w] <C-W>]
nmap <leader>wg] <C-W>g]
nmap <leader>J <C-W>J
nmap <leader>K <C-W>K
nmap <leader>H <C-W>H
nmap <leader>L <C-W>L
nmap <leader>wc :bd!<cr>
nmap <leader>we <C-W>=
nmap <leader>wz <C-W>z
nmap <leader>so :source %<CR>
nmap <leader>hl :let &hlsearch=1-&hlsearch<CR>
nmap <leader>ma :make<cr>
nmap <leader>cn :cnext<cr>
nmap <leader>cp :cprev<cr>
nmap <leader>cw :botright cwindow<cr>
nmap <leader>cl :ccl<cr>
nmap <leader>cf :cs find s <C-R>=expand("<cword>")<CR><CR>
nmap <leader>@ "zyy:@z<CR>
nmap <leader>ie /,\n\s*}<CR>
nnoremap <C-N> }
nnoremap <C-P> {
nnoremap <C-L> )
nnoremap ( [(
nnoremap ) ])
nnoremap { [{
nnoremap } ]}
nnoremap <C-J> 10j
nnoremap <C-K> 10k
vnoremap <C-N> }
vnoremap <C-P> {
vnoremap <C-L> )
vnoremap ( [(
vnoremap ) ])
vnoremap { [{
vnoremap } ]}
vnoremap <C-J> 10j
vnoremap <C-K> 10k

cmap <C-h> <LEFT>
cmap <C-k> <UP>
cmap <C-j> <DOWN>
cmap <C-l> <RIGHT>
cmap <C-B> <C-LEFT>
cmap <C-F> <C-RIGHT>
cmap <C-A> <HOME>
cmap <C-E> <END>
cmap <S-CR> <C-U><ESC>
cmap <C-V> <C-R><C-W>
cab erc :tabe ~/.vimrc<cr>
cab src :source ~/.vimrc<cr>
cab vsb vertical sb
cab res resize
cab vres vertical resize
cab te tabe
cab cwd lcd %:p:h
cab cf :cs find 
cab ses mksession! session.vim
cab seo source session.vim

" Insert and command-line mode Caps Lock.
" Lock search keymap to be the same as insert mode.
set imsearch=-1
" Load the keymap that acts like capslock.
set keymap=insert-only_capslock
set iminsert=0
inoremap <C-E> <C-^>

:highlight Cursor guifg=NONE guibg=Green
:highlight lCursor guifg=NONE guibg=Cyan

"====Plugin Settings=====
"-taglist-
let Tlist_Ctags_Cmd = "ctags"
let Tlist_File_Fold_Auto_Close = 1
let Tlist_Use_Right_Window = 1
let Tlist_Show_One_File = 1
let tlist_objc_settings = 'objc;c:class;p:protocol;m:instance method;M:class method;P:protocol'
let tlist_actionscript_settings = 'actionscript;c:class;f:method;p:property;v:variable'
nmap ;a :TlistToggle<CR>
cab ct silent !ctags --langmap='c++:+.cu.cuh' *
"-NERDTree-
nmap <leader>nd :NERDTreeToggle<CR>
nmap <leader>nf :NERDTreeFind<CR>
"-NERDCommenter-
let g:NERDCreateDefaultMappings = 0
nmap <leader>cc <plug>NERDCommenterComment
vmap <leader>cc <plug>NERDCommenterComment
nmap <leader>cu <plug>NERDCommenterUncomment
vmap <leader>cu <plug>NERDCommenterUncomment
nmap <leader>cs <plug>NERDCommenterSexy
vmap <leader>cs <plug>NERDCommenterSexy
nmap <leader>c<space> <plug>NERDCommenterToggle
vmap <leader>c<space> <plug>NERDCommenterToggle

"-CtrlP-
nmap ;s :CtrlPMRU<CR>
nmap ;d :CtrlP<CR>
nmap ;f :CtrlPBuffer<CR>
nmap ;t :CtrlPTag<CR>
nmap ;g :CtrlPBufTag<CR>
nmap ;h :CtrlPClearCache<CR>
nmap ;H :CtrlPClearAllCaches<CR>
let g:ctrlp_extensions = ['buffertag', 'tag']
let g:ctrlp_buftag_types = { 'objc' : '--language-force=objc' }

"-Neocomplcache-
let g:neocomplcache_enable_at_startup = 1
let g:neocomplcache_max_list = 20
let g:neocomplcache_plugin_disable = {'include_complete' : 1, 'filename_complete' : 1}
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_snippets_dir = expand("~/.vim/snippets")
imap <tab>    <Plug>(neocomplcache_snippets_expand)
smap <tab>    <Plug>(neocomplcache_snippets_expand)

"-TAssert
let g:TLOG='Decho'

"-ConqueTerm
cnorea ipython ConqueTerm ipython

"-Decho
let g:decho_winheight=15
function! DechoSystem(cmd)
	let result = system(a:cmd)
	for line in split(result, '\n')
		call Decho(line)
	endfor
endfunction

"Perl Settings
let perl_fold = 1
let perl_nofold_packages = 1

"Python Settings
let pydoc_highlight = 0

inoremap <C-]> <ESC>:call g:show_func_arg()<CR>a
nmap ,fi :call g:show_func_arg()<CR>
nmap ,fc :call g:close_func_arg_win()<CR>

"Vim-Ref
let g:ref_jquery_path=$HOME . '/.vim/ref-doc/jquery'

"Quickrun
map <unique> <Leader>qr <Plug>(quickrun)

"====USER DEFINED FUNCTION===
command! -nargs=1 SearchCurrentFile :call s:SearchCurrentFile(<q-args>)
nmap <leader>* :SearchCurrentFile <C-R>=expand('<cword>')<CR><CR>
vmap <leader>* "zy:SearchCurrentFile <C-R>=getreg('z')<CR><CR>

function! s:SearchCurrentFile(pattern)
	let searchcmd = 'vimgrep '. a:pattern . ' ' . expand("%")
	exec searchcmd
endfunction

command! -nargs=1 SmartGrep :call s:SmartGrep(<q-args>)
command! -nargs=1 SmartReplace :call s:SmartReplace(<q-args>)
cab sgrep SmartGrep
cab srep SmartReplace
nmap <leader>gr :SmartGrep <C-R>=expand('<cword>')<CR><CR>
vmap <leader>gr "zy:SmartGrep <C-R>=getreg('z')<CR><CR>
nmap <leader>re :SmartReplace <C-R>=expand('<cword>')<CR><CR>
vmap <leader>re "zy:SmartReplace <C-R>=getreg('z')<CR><CR>
let g:smartGrep_rules = []

function! LookupDirs(curfile)
	let dir = "**/*." . expand("%:t:e")
	for rule in g:smartGrep_rules
		if a:curfile =~ rule[0]
			let dir = rule[1]
			break
		endif
	endfor
	return dir
endfunction

function! s:SmartGrep(pattern)
	let curfile = bufname('%')
	let grepcmd = 'silent grep ' . a:pattern . ' ' . LookupDirs(curfile)
	exec grepcmd
	exec 'botright cwindow'
	exec 'redraw!'
endfunction

function! s:SmartReplace(pattern, ...)
	let sub = a:0 > 1 ? a:1 : input("Replace '" . a:pattern . "' with: ")
	if sub == ''
		return
	endif
	exec 'wa'
	let curfile = bufname('%')
	let grepcmd = 'grep -nH ' . a:pattern . ' ' . LookupDirs(curfile)
	let matches = system(grepcmd)
	let match_list = split(matches, '\n')
	let match_files = []
	for i in range(len(match_list))
		let filename = substitute(match_list[i], ':.*$', '', '')
		if count(match_files, filename) == 0
			call add(match_files, filename)
		endif
	endfor
	let choice = input(matches . "Are you sure to replace all those occurences with '" . sub . "'([y]es/[n]o/[c]onfirm)?")
	if choice == 'y' || choice == 'Y' || choice == 'c' || choice == 'C'
		exec 'args ' . join(match_files, ' ')
		let confirm = (choice == 'c' || choice == 'C') ? 'c' : ''
		exec 'argdo %s/' . a:pattern . '/' . sub . '/g' . confirm
	endif
endfunction

"hex
if has('Python')
    nmap ,h :call HexValueInfo()<CR>
endif

function! HexValueInfo()
python <<EOF
    import vim, re, struct
    val = vim.eval('expand("<cword>")')
    val = eval(val)
    fval = struct.unpack('f', struct.pack("I", val))[0]
    #add comma to decimal value
    dval = str(val)
    dval = dval[::-1]
    dval = re.sub(r'(\d\d\d)(?=\d)',r'\1,',dval)
    dval = dval[::-1]
    print "val: 0x%x/%s/%g" % (val, dval, fval)
EOF
endfunction

"Paste mod
nmap <leader>pa :call TogglePasteMode()<CR>
function! TogglePasteMode()
	if &paste == 1
		let &paste = 0
		echo 'Paste Mode Off'
	else
		let &paste = 1
		echo 'Paste Mode On'
	endif
endfunction
